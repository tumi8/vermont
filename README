This is VERMONT - VERsatile MONitoring Tool.
Released under GPL2
Project website: http://vermont.berlios.de 

------------
REQUIREMENTS
------------

VERMONT has been tested on Linux and FreeBSD systems.

For compilation, GNU C/C++ compiler and standard libraries are required,
as well as the following Ubuntu/Debian packages (or equivalent packages
of other Linux distributions):
 - cmake 
 - cmake-curses-gui - Curses based user interface for CMake (ccmake)
 - libboost-filesystem-dev
 - libboost-regex-dev
 - libboost-test-dev
 - libxml2-dev 
 - libpcap-dev 
 - libsctp-dev (if not available, disable cmake option SUPPORT_SCTP)

The following packages are optional:
 - cmake-curses-gui (ccmake, interactive user interface of cmake)
 - libpq-dev (for PostGreSQL support)
    ==> cmake option SUPPORT_PGSQL
 - libmysqlclient-dev (for MySQL support)
    ==> cmake option SUPPORT_MYSQL
 - libgsl-dev (for connection-based sampling with Bloom filters)
    ==> cmake option USE_GSL


-------------------------
BUILDING AND INSTALLATION
-------------------------

This project uses cmake for setting platform- and user-specific compile 
options. In order to generate the Makefile for actual compilation, you 
need to call in the root of the source directory:

$ cmake .

In order to change the default compile options, use:

$ cmake -D OPTION1=value1 -D OPTION2=value2 ...

To get a list of the most important options, call:

$ cmake -LH
   
As a user-friendly alternative, you can use the interactive user interface.
Please note that this requires the package cmake-curses-gui, if you are using
Debian.

$ ccmake .

If some libraries are installed in custom directories, use:

$ cmake -D CMAKE_PREFIX_PATH=/custom/directory1:/custom/directory2

After successfully generating the Makefile with cmake, start the 
compilation with:

$ make

Although not strictly necessary, VERMONT binaries and data files can be 
copied to the usual install location by running:

$ make install 

--------------------------------------
BUILDING WITH DTLS SUPPORT
--------------------------------------

VERMONT's DTLS support is based on OpenSSL. The DTLS implementation in OpenSSL
is fairly new and probably not as mature as the TLS/SSL implementation.  You
are strongly advised to use the very latest version of OpenSSL which you can
get from the CVS repository. At the time of writing, Ubuntu, for example, ships
OpenSSL version 0.9.8k which should not be used for DTLS because it has many
bugs.

You can get the latest OpenSSL source by using the following command:

cvs -z9 -d anonymous@cvs.openssl.org:/openssl-cvs co openssl

You probably do not want the development version of the OpenSSL library to
become the default version of your system. The reason behind this is that the
development version might contain bugs and be incompatible with other packages
in your distribution. It is therefore recommended installing the development
version in a separate directory.

For example, if you want to install OpenSSL into /home/daniel/da/openssl, you
can use the following command to configure the build.

./config -d no-dso no-shared --prefix=/home/daniel/da/openssl

The switch no-dso turns off the use of shared-library methods which avoids
linking problems related to libdl on the Linux platform.
With no-shared on the command line, no shared but only static libraries are
built. This should make it easier to link VERMONT to the correct version of
OpenSSL.

As the next step, you may run

make && make install

which builds and installs OpenSSL in the directory you specified with --prefix
when running ./config.

As soon as you completed this step, you go back to the source directory of VERMONT and
run the following command to configure the build.

cmake -DSUPPORT_DTLS=YES -DCMAKE_INCLUDE_PATH=/home/daniel/da/openssl/include -DCMAKE_LIBRARY_PATH=/home/daniel/da/openssl/lib

-DCMAKE_INCLUDE_PATH and -DCMAKE_LIBRARY_PATH allow cmake to locate your
freshly built version of OpenSSL. On 64 bit platforms, it might be necessary to
use the following command line instead. Mind the "64" at the very end:

cmake -DSUPPORT_DTLS=YES -DCMAKE_INCLUDE_PATH=/home/daniel/da/openssl/include -DCMAKE_LIBRARY_PATH=/home/daniel/da/openssl/lib64

After running make, you should be ready to use VERMONT with support for IPFIX
over DTLS over UDP. Please read the next section if you require support for
DTLS over SCTP as well.

--------------------------------------
BUILDING WITH DTLS OVER SCTP SUPPORT
--------------------------------------
First of all, it should be noted that DTLS over SCTP can be used on FreeBSD
only! This is due to the fact that FreeBSD is the only OS -- at least at the
time of writing -- that supports the SCTP-AUTH extension (see RFC 4895).

The upstream version of OpenSSL has no support for SCTP. You have to download
some patches from

http://sctp.fh-muenster.de/

and apply them to the OpenSSL source tree before you are able to build OpenSSL.
When doing so, you should be careful that you download a version of OpenSSL
that the patches can be applied to. At the time of writing, the patches from
the website applied cleanly to OpenSSL 1.0.0a. However, you can usually apply
them to the latest development version from the CVS repository with little
manual intervention.

Also, make sure to add the command line argument "sctp" when running OpenSSL's
./config to build SCTP support into OpenSSL.

When running cmake, add -DSUPPORT_DTLS_OVER_SCTP to the command line. It should
be noted that -DSUPPORT_DTLS and -DSUPPORT_SCTP have to be on the command line
as well. DTLS and SCTP support is obviously a requirement for DTLS over SCTP.

-----------------------
USAGE AND CONFIGURATION
-----------------------

In order to run VERMONT, a configuration file is needed which specifies the 
modules to be used and their parameters:

$ ./vermont -f <config-file>

Example configuration files can be found in configs/.
A documentation of the available modules and their configuration parameters
can be found at http://vermont.berlios.de/vermont_module_configuration .
A snapshot of this file is located at docs/config/. 

Use Ctrl-C to stop VERMONT. If VERMONT does not exit properly, enter Ctrl-C
for a second time.


--------------------------------------
TRAFFIC CAPTURING AT VLAN MIRROR PORTS
--------------------------------------

VERMONT can be used to capture traffic at a mirror port of a switch. If
the mirror port is configured for VLAN traffic, the Ethernet frames will
usually include a VLAN tag in the Ethernet header, increasing the header 
length from 14 to 18 bytes.

In order to capture such traffic correctly, you need to set the cmake 
option IP_HEADER_OFFSET to 18. Furthermore, make sure that the observer
is configured with <pap_filter> parameter set to "vlan and ip".


----------------------------------------------------
OPERATION AS COLLECTOR: TUNING SOCKET RECEIVE BUFFER
----------------------------------------------------

VERMONT can be used as an IPFIX/PSAMP and NetFlow.v9 collector. As the 
incoming IPFIX/PSAMP/NetFlow messages usually arrive in bursts, losses 
may occur due to insufficient buffer space.

As a solution, the socket receive buffer can be increased. To check the
current settings, use the following system calls on Linux systems with 
/proc file system:

$ cat /proc/sys/net/core/rmem_default
$ cat /proc/sys/net/core/rmem_max

In order to configure a new value X (in bytes), call:

$ sysctl -w net/core/rmem_default=X
$ sysctl -w net/core/rmem_max=X


------------------------------------
OPTIMIZED PACKET CAPTURING WITH PCAP
------------------------------------

To reduce the number of times packets need to be copied on their way from
the network interface card to the user space (i.e., VERMONT), we recommend 
the utilization of pcap library 1.0.0 or higher.

For earlier versions of pcap, the pcap-mmap patch can be applied to 
improve the performance: http://public.lanl.gov/cpw/


-------------------------------------
EFFECTS OF RECEIVE OFFLOAD MECHANISMS
-------------------------------------

Several mechanisms have been implemented in modern network interface cards,
drivers, and kernels to offload common functions from the protocol stack and 
the application. One particular focus is on TCP segmentation and reassembly.

Receive offload mechanisms aim at reassembling subsequent TCP segments into
a single large packet before passing it to the IP/TCP protocol stack and 
finally to the application. In the Linux kernel, this is done by generic 
receive offload (GRO) if the network interface card and the driver support 
NAPI. Latest Intel 10GE controllers (e.g., 82599) support receive side 
coalescing (RSC) which performs TCP reassembly in hardware.

If any receive offload mechanism is enabled, VERMONT (like any other 
pcap-based application) does not observe the actually captured TCP packets 
but the reassembled ones. One consequence is that packet counts of flows will 
be smaller than the true number of packets.

In order to avoid such distortions, all receive offload mechanisms need to 
be disabled. In the case of GRO (and the older LRO), this can be done with 
ethtool. The following call returns a list of the current status of all 
offload mechanisms for interface <dev>:

$ ethtool -k <dev>

If GRO is not shown, you probably need to install a newer version of ethtool.
To disable GRO (and LRO), execute:

$ ethtool -K <dev> gro off
$ ethtool -K <dev> lro off

Hardware-based RSC can be deactivated at compile time of the driver as 
explained here:
http://downloadmirror.intel.com/19004/eng/README-2.0.72.4.txt

