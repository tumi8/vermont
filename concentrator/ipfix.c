/** @file
 * IPFIX protocol constants.
 *
 * This function provides constants and functions necessary or useful for interpretation of IPFIX messages.
 *
 */

#include <string.h>
#include "ipfix.h"

int string2typeid(char*s) {
	if (strcmp(s, "ipVersion"                   ) == 0) return 60; 
	if (strcmp(s, "sourceIPv4Address"           ) == 0) return 8; 
	if (strcmp(s, "sourceIPv6Address"           ) == 0) return 27; 
	if (strcmp(s, "sourceIPv4Mask"              ) == 0) return 9; 
	if (strcmp(s, "sourceIPv6Mask"              ) == 0) return 29; 
	if (strcmp(s, "sourceIPv4Prefix"            ) == 0) return 44; 
	if (strcmp(s, "destinationIPv4Address"      ) == 0) return 12; 
	if (strcmp(s, "destinationIPv6Address"      ) == 0) return 28; 
	if (strcmp(s, "destinationIPv4Mask"         ) == 0) return 13; 
	if (strcmp(s, "destinationIPv6Mask"         ) == 0) return 30; 
	if (strcmp(s, "destinationIPv4Prefix"       ) == 0) return 45; 
	if (strcmp(s, "classOfServiceIPv4"          ) == 0) return 5; 
	if (strcmp(s, "classOfServiceV6"            ) == 0) return 137; 
	if (strcmp(s, "flowLabelV6"                 ) == 0) return 31; 
	if (strcmp(s, "identificationV4"            ) == 0) return 54; 
	if (strcmp(s, "protocolIdentifier"          ) == 0) return 4; 
	if (strcmp(s, "sourceTransportPort"         ) == 0) return 7; 
	if (strcmp(s, "destinationtransportPort"    ) == 0) return 11; 
	if (strcmp(s, "icmpTypeCode"                ) == 0) return 32; 
	if (strcmp(s, "igmpType"                    ) == 0) return 33; 
	if (strcmp(s, "sourceMacAddress"            ) == 0) return 56; 
	if (strcmp(s, "mplsLabelStackEntry1"        ) == 0) return 70; 
	if (strcmp(s, "mplsLabelStackEntry2"        ) == 0) return 71; 
	if (strcmp(s, "mplsLabelStackEntry3"        ) == 0) return 72; 
	if (strcmp(s, "mplsLabelStackEntry4"        ) == 0) return 73; 
	if (strcmp(s, "mplsLabelStackEntry5"        ) == 0) return 74; 
	if (strcmp(s, "mplsLabelStackEntry6"        ) == 0) return 75; 
	if (strcmp(s, "mplsLabelStackEntry7"        ) == 0) return 76; 
	if (strcmp(s, "mplsLabelStackEntry8"        ) == 0) return 77; 
	if (strcmp(s, "mplsLabelStackEntry9"        ) == 0) return 78; 
	if (strcmp(s, "mplsLabelStackEntry10"       ) == 0) return 79; 
	if (strcmp(s, "ipNextHopIPv4Address"        ) == 0) return 15; 
	if (strcmp(s, "ipNextHopIPv6Address"        ) == 0) return 62; 
	if (strcmp(s, "ingressInterface"            ) == 0) return 10; 
	if (strcmp(s, "egressInterface"             ) == 0) return 14; 
	if (strcmp(s, "ipNextHopAsNumber"           ) == 0) return 129; 
	if (strcmp(s, "bgpSourceAsNumber"           ) == 0) return 16; 
	if (strcmp(s, "bgpDestinationAsNumber"      ) == 0) return 17; 
	if (strcmp(s, "bgpNextHopAsNumber"          ) == 0) return 128; 
	if (strcmp(s, "bgpNextHopIPv4Address"       ) == 0) return 18; 
	if (strcmp(s, "bgpNextHopIPv6Address"       ) == 0) return 63; 
	if (strcmp(s, "mplsTopLabelType"            ) == 0) return 46; 
	if (strcmp(s, "mplsTopLabelIPv4Address"     ) == 0) return 47; 
	if (strcmp(s, "mplsTopLabelIPv6Address"     ) == 0) return 140; 
	if (strcmp(s, "exporterIPv4Address"         ) == 0) return 130; 
	if (strcmp(s, "exporterIPv6Address"         ) == 0) return 131; 
	if (strcmp(s, "minPacketLength"             ) == 0) return 25; 
	if (strcmp(s, "maxPacketLength"             ) == 0) return 26; 
	if (strcmp(s, "minimumTTL"                  ) == 0) return 52; 
	if (strcmp(s, "maximumTTL"                  ) == 0) return 53; 
	if (strcmp(s, "ipv6OptionHeaders"           ) == 0) return 64; 
	if (strcmp(s, "tcpControlBits"              ) == 0) return 6; 
	if (strcmp(s, "flowCreationTime"            ) == 0) return 22; 
	if (strcmp(s, "flowEndTime"                 ) == 0) return 21; 
	if (strcmp(s, "flowActiveTimeOut"           ) == 0) return 36; 
	if (strcmp(s, "flowInactiveTimeout"         ) == 0) return 37; 
	if (strcmp(s, "flowEndReason"               ) == 0) return 136; 
	if (strcmp(s, "inOctetDeltaCount"           ) == 0) return 1; 
	if (strcmp(s, "outOctetDeltaCount"          ) == 0) return 23; 
	if (strcmp(s, "octetDeltaCount"             ) == 0) return 138; 
	if (strcmp(s, "octetTotalCount"             ) == 0) return 85; 
	if (strcmp(s, "inPacketDeltaCount"          ) == 0) return 2; 
	if (strcmp(s, "outPacketDeltaCount"         ) == 0) return 24; 
	if (strcmp(s, "packetDeltaCount"            ) == 0) return 139; 
	if (strcmp(s, "packetTotalCount"            ) == 0) return 86; 
	if (strcmp(s, "droppedOctetDeltaCount"      ) == 0) return 132; 
	if (strcmp(s, "droppedOctetTotalCount"      ) == 0) return 133; 
	if (strcmp(s, "droppedPacketDeltaCount"     ) == 0) return 134; 
	if (strcmp(s, "droppedPacketTotalCount"     ) == 0) return 135; 
	if (strcmp(s, "outMulticastPacketCount"     ) == 0) return 19; 
	if (strcmp(s, "outMulticastOctetCount"      ) == 0) return 20; 
	if (strcmp(s, "observedFlowTotalCount"      ) == 0) return 3; 
	if (strcmp(s, "exportedOctetTotalCount"     ) == 0) return 40; 
	if (strcmp(s, "exportedPacketTotalCount"    ) == 0) return 41; 
	if (strcmp(s, "exportedFlowTotalCount"      ) == 0) return 42; 
	return 0;
	}

char* typeid2string(int i) {
	if (i ==  60) return "ipVersion"; 
	if (i ==   8) return "sourceIPv4Address"; 
	if (i ==  27) return "sourceIPv6Address"; 
	if (i ==   9) return "sourceIPv4Mask"; 
	if (i ==  29) return "sourceIPv6Mask"; 
	if (i ==  44) return "sourceIPv4Prefix"; 
	if (i ==  12) return "destinationIPv4Address"; 
	if (i ==  28) return "destinationIPv6Address"; 
	if (i ==  13) return "destinationIPv4Mask"; 
	if (i ==  30) return "destinationIPv6Mask"; 
	if (i ==  45) return "destinationIPv4Prefix"; 
	if (i ==   5) return "classOfServiceIPv4"; 
	if (i == 137) return "classOfServiceV6"; 
	if (i ==  31) return "flowLabelV6"; 
	if (i ==  54) return "identificationV4"; 
	if (i ==   4) return "protocolIdentifier"; 
	if (i ==   7) return "sourceTransportPort"; 
	if (i ==  11) return "destinationtransportPort"; 
	if (i ==  32) return "icmpTypeCode"; 
	if (i ==  33) return "igmpType"; 
	if (i ==  56) return "sourceMacAddress"; 
	if (i ==  70) return "mplsLabelStackEntry1"; 
	if (i ==  71) return "mplsLabelStackEntry2"; 
	if (i ==  72) return "mplsLabelStackEntry3"; 
	if (i ==  73) return "mplsLabelStackEntry4"; 
	if (i ==  74) return "mplsLabelStackEntry5"; 
	if (i ==  75) return "mplsLabelStackEntry6"; 
	if (i ==  76) return "mplsLabelStackEntry7"; 
	if (i ==  77) return "mplsLabelStackEntry8"; 
	if (i ==  78) return "mplsLabelStackEntry9"; 
	if (i ==  79) return "mplsLabelStackEntry10"; 
	if (i ==  15) return "ipNextHopIPv4Address"; 
	if (i ==  62) return "ipNextHopIPv6Address"; 
	if (i ==  10) return "ingressInterface"; 
	if (i ==  14) return "egressInterface"; 
	if (i == 129) return "ipNextHopAsNumber"; 
	if (i ==  16) return "bgpSourceAsNumber"; 
	if (i ==  17) return "bgpDestinationAsNumber"; 
	if (i == 128) return "bgpNextHopAsNumber"; 
	if (i ==  18) return "bgpNextHopIPv4Address"; 
	if (i ==  63) return "bgpNextHopIPv6Address"; 
	if (i ==  46) return "mplsTopLabelType"; 
	if (i ==  47) return "mplsTopLabelIPv4Address"; 
	if (i == 140) return "mplsTopLabelIPv6Address"; 
	if (i == 130) return "exporterIPv4Address"; 
	if (i == 131) return "exporterIPv6Address"; 
	if (i ==  25) return "minPacketLength"; 
	if (i ==  26) return "maxPacketLength"; 
	if (i ==  52) return "minimumTTL"; 
	if (i ==  53) return "maximumTTL"; 
	if (i ==  64) return "ipv6OptionHeaders"; 
	if (i ==   6) return "tcpControlBits"; 
	if (i ==  22) return "flowCreationTime"; 
	if (i ==  21) return "flowEndTime"; 
	if (i ==  36) return "flowActiveTimeOut"; 
	if (i ==  37) return "flowInactiveTimeout"; 
	if (i == 136) return "flowEndReason"; 
	if (i ==   1) return "inOctetDeltaCount"; 
	if (i ==  23) return "outOctetDeltaCount"; 
	if (i == 138) return "octetDeltaCount"; 
	if (i ==  85) return "octetTotalCount"; 
	if (i ==   2) return "inPacketDeltaCount"; 
	if (i ==  24) return "outPacketDeltaCount"; 
	if (i == 139) return "packetDeltaCount"; 
	if (i ==  86) return "packetTotalCount"; 
	if (i == 132) return "droppedOctetDeltaCount"; 
	if (i == 133) return "droppedOctetTotalCount"; 
	if (i == 134) return "droppedPacketDeltaCount"; 
	if (i == 135) return "droppedPacketTotalCount"; 
	if (i ==  19) return "outMulticastPacketCount"; 
	if (i ==  20) return "outMulticastOctetCount"; 
	if (i ==   3) return "observedFlowTotalCount"; 
	if (i ==  40) return "exportedOctetTotalCount"; 
	if (i ==  41) return "exportedPacketTotalCount"; 
	if (i ==  42) return "exportedFlowTotalCount"; 
	return NULL;
	}

int string2typelength(char*s) {
	if (strcmp(s, "ipVersion"                   ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "sourceIPv4Address"           ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "sourceIPv6Address"           ) == 0) return IPFIX_LENGTH_ipv6Address; 
	if (strcmp(s, "sourceIPv4Mask"              ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "sourceIPv6Mask"              ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "sourceIPv4Prefix"            ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "destinationIPv4Address"      ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "destinationIPv6Address"      ) == 0) return IPFIX_LENGTH_ipv6Address; 
	if (strcmp(s, "destinationIPv4Mask"         ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "destinationIPv6Mask"         ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "destinationIPv4Prefix"       ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "classOfServiceIPv4"          ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "classOfServiceV6"            ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "flowLabelV6"                 ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "identificationV4"            ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "protocolIdentifier"          ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "sourceTransportPort"         ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "destinationtransportPort"    ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "icmpTypeCode"                ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "igmpType"                    ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "sourceMacAddress"            ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "mplsLabelStackEntry1"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry2"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry3"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry4"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry5"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry6"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry7"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry8"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry9"        ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "mplsLabelStackEntry10"       ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "ipNextHopIPv4Address"        ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "ipNextHopIPv6Address"        ) == 0) return IPFIX_LENGTH_ipv6Address; 
	if (strcmp(s, "ingressInterface"            ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "egressInterface"             ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "ipNextHopAsNumber"           ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "bgpSourceAsNumber"           ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "bgpDestinationAsNumber"      ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "bgpNextHopAsNumber"          ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "bgpNextHopIPv4Address"       ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "bgpNextHopIPv6Address"       ) == 0) return IPFIX_LENGTH_ipv6Address; 
	if (strcmp(s, "mplsTopLabelType"            ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "mplsTopLabelIPv4Address"     ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "mplsTopLabelIPv6Address"     ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "exporterIPv4Address"         ) == 0) return IPFIX_LENGTH_ipv4Address; 
	if (strcmp(s, "exporterIPv6Address"         ) == 0) return IPFIX_LENGTH_ipv6Address; 
	if (strcmp(s, "minPacketLength"             ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "maxPacketLength"             ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "minimumTTL"                  ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "maximumTTL"                  ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "ipv6OptionHeaders"           ) == 0) return IPFIX_LENGTH_unsigned32; 
	if (strcmp(s, "tcpControlBits"              ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "flowCreationTime"            ) == 0) return IPFIX_LENGTH_dateTimeSeconds; 
	if (strcmp(s, "flowEndTime"                 ) == 0) return IPFIX_LENGTH_dateTimeSeconds; 
	if (strcmp(s, "flowActiveTimeOut"           ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "flowInactiveTimeout"         ) == 0) return IPFIX_LENGTH_unsigned16; 
	if (strcmp(s, "flowEndReason"               ) == 0) return IPFIX_LENGTH_octet; 
	if (strcmp(s, "inOctetDeltaCount"           ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "outOctetDeltaCount"          ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "octetDeltaCount"             ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "octetTotalCount"             ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "inPacketDeltaCount"          ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "outPacketDeltaCount"         ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "packetDeltaCount"            ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "packetTotalCount"            ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "droppedOctetDeltaCount"      ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "droppedOctetTotalCount"      ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "droppedPacketDeltaCount"     ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "droppedPacketTotalCount"     ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "outMulticastPacketCount"     ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "outMulticastOctetCount"      ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "observedFlowTotalCount"      ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "exportedOctetTotalCount"     ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "exportedPacketTotalCount"    ) == 0) return IPFIX_LENGTH_unsigned64; 
	if (strcmp(s, "exportedFlowTotalCount"      ) == 0) return IPFIX_LENGTH_unsigned64; 
	return 0;
	}
